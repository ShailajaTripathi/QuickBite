// episode-2
There are 2 type of dependencies: 
Dev Dependency - when we are developing our app then we  require that dev dependencies 
Normal Dependency - are used in production also

parcel is a bundler,beast, will give a strength to our app
parcel is a "transitive dependency" which is a dependencyhaving lots of dependenciesin it and those dependencieshave their own dependencies
they all dependent on each other


package.json is the configuration for NPM
package.lock.json keeps track of all versions. 
node modules-- it is like a database which holds data of all the dependencies used in our project,it feteches all the code of all the dependencies to our local system thats why it is a very very heavy
node modules is a collection of dependencies .
if we have package.json and package.lock.json then we can recreate our node_modules by "npm install"

npm --- to install
npx ---- to execute / run

cdn links are not a good way to add react because we cann't change those cdn links after update of react version so we always install react as a package  

browserslist(can visit to its documentation) --- by applying this on package.json it will specify which version(older to latest) will support this app

// episode - 3

React element is object react element it is not a html element if we render react element on browser then it becomes a html element by using ReactDOM
JSX Javascript syntax(HTML like syntax) to make react code easy.
JSX(transpiled before it reaches the js engine ) by PARCEL babel do transpiled for parcel
JSX -> PARCEL -> Babel(it is js compiler or transpiler);
React Element ->  is js object => HTMLElement (render)

JSX  -> Babel transpiles -> rect.createElement => ReactElement  - JS object => HTMLElement

-- chunking
-- code splitting
-- dynamic bundling
-- lazy loading ----- {lazy()} by react 
--- on demand loading
-- dynamic import

React Component -
1. class based components (old way)
2. funcional components(new)

React funcional components are normal js functions which return some JSX code
Component composition => we are composing composition (component inside component)
JSX sanitize our code it protects our code from malicious attack,
<Component/>  OR <Component></Component> OR {Component()}  all are same way to compose or call any component 

props are normal arguments as passing to a function for funcitonal component

//config (json data) driven UI --> when UI comes from json data

 never use index as a key in loop i.e map,foreach always use unique id // its ok but not recommended


 ## --- Monolith architechture --- ## 
  - Traditionally when webapps were developed ther were all developed using monolith architecture 
  - i.e earlier we have ahuge big project containing APIs, UI code,Auth code,database, sms connectivity etc.
   we have to do all of these in same project  and we have to update any UI oranything inside it we have to setup everything irst in our system as a project then we have to do any change in same project


 ## --Microservise architechture--##
In this architechture we have different service for different job
like we have backend service,UI service,auth service,sms sending service, db services all of these service combined together amkes a big app
this is known as seperation of concerns and single responsibilty principle
where each and every single service has its own job

there are 2 ways to fetch data from backend
1. Load page  -> API call -> Render the page
2. Load page  -> Render the page -> call API -> render with the API data on page (good approch to render less)

## Whenever state variable update,react triggers a reconciliation cycle(re-render the component)

## UseEffect-- This will render after every render

 ##Routing--
 React is single page application which uses client side routing
 1. client side Routing -- No network call all the apps and pages already loaded to our app ,so we are not fetching any page like server side routing 
 2 server side routing --- (routing through network call)when u make a call from network

## UI layer & Data layer
## Controlled and uncontrolled component (lifting the state up (to parent comp. --state--> (props)child comp.))
-- controlled component: controlled by passsing its states and setstate callback fn by props
--  uncontrolled component : the components having controlled by their own states and all

$$ Controlled Component (Parent : State Owner) : Component which has a state which control UI, in this process *Parent becomes Controlled Component*
$$ Uncontrolled Component : Children Components Which are  receveing props and updating UI according to that props are uncontrolled component. 

## Lifting State up---
This concept is used when we have to share any state among more than one child component.
During this process state needs to be `lifting up` to parent component so that parent can manage that state and pass it through the props among children accordingly 

## context API (to avoid prop drilling its a global context shares data across the components)
- to create context - createContext from react
- to use context  - useContext hook from react

we can pass props as we needd anywhere but if we need same data in multiple component or in multiple component tree then context api is plays its useful role.
for ex. of context api : Theme, loggedin user details,etc.

## Provider in Context api 
- wrap the whole app inside Provider then pass the data as a props into the provider to change it dynamically 
